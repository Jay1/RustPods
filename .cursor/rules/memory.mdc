---
description: 
globs: 
alwaysApply: true
---
# Rust Memory Management Guidelines

## Memory Ownership and Lifetimes
- Follow Rust's ownership model: each value has a single owner
- Use references with proper lifetimes for temporary borrowing
- Implement Copy or Clone traits appropriately
- Prefer stack-allocated data when possible

## Resource Management
- Use RAII (Resource Acquisition Is Initialization) pattern
- Leverage `Drop` trait for automatic resource cleanup
- Implement proper error handling with `Result<T, E>`
- Avoid unnecessary heap allocations for small, short-lived objects

## Performance Optimization
- Profile memory usage with tools like `heaptrack` or DHAT
- Use Rust's built-in benchmarking for performance testing
- Consider using custom allocators for specific use cases
- Optimize data structures for the specific access patterns

## Bluetooth-Specific Considerations
- Minimize buffer copies when processing BLE packets
- Handle device disconnections gracefully to prevent resource leaks
- Properly manage async tasks related to BLE scanning to avoid memory bloat
- Use appropriate buffer sizes for BLE communication

## Concurrency Best Practices
- Prefer message passing over shared memory with `std::sync::mpsc`
- Use `Arc<T>` for shared ownership across threads
- Leverage the `tokio` runtime for efficient asynchronous operations
- Always handle task cancellation and cleanup appropriately

## UI Memory Management
- Use the Iced framework's state management patterns
- Minimize cloning of large data structures in UI rendering loops
- Use references when passing data to UI components
- Be cautious with caching rendered UI components

## UI Component Lifetime Management
- Avoid returning references to temporary values in `view()` methods
- Use wrapper components that own their data for complex UI elements
- Implement `From<Component> for Element<'_, Message>` for components used in column/row macros
- Create `render()` methods that return owned `Element<'static, Message>` values
- Break complex UI components into smaller helper methods that own their return values
- When component borrows cause lifetime issues, consider refactoring to use component composition
- Use the wrapper component pattern to avoid the "cannot return value referencing temporary value" error

# AI Memory Rule

This rule defines how the AI should manage and utilize its "memory" regarding the RustPods project, including user preferences, learned facts, and project-specific conventions.

## Purpose

The AI's memory helps maintain consistency and adapt to specific project needs or user preferences discovered during interactions. It prevents the AI from repeatedly asking for the same information or making suggestions contrary to established patterns.

## Storage

All learned project-specific knowledge and preferences should be stored and referenced in the `learned-memories.mdc` file located in `.cursor/rules`.

## Updating Memory

When new information relevant to the project's conventions, user preferences, or specific technical details is learned (either explicitly told by the user or inferred through conversation), the AI should:

1. **Identify Key Information:** Determine the core piece of knowledge to be stored.
2. **Check Existing Memory:** Review `learned-memories.mdc` to see if this information contradicts or updates existing entries.
3. **Propose Update:** Suggest an edit to `learned-memories.mdc` to add or modify the relevant information. Keep entries concise and clear.

## Using Memory

Before proposing solutions, code changes, or answering questions, the AI should consult `learned-memories.mdc` to ensure its response aligns with the recorded knowledge and preferences.

## Example Scenario

**User:** "We've decided to use tokio 1.28 specifically for this project due to compatibility issues with newer versions."

**AI Action:**

1. Recognize this as a project-specific technical decision.
2. Check `learned-memories.mdc` for existing tokio version information.
3. Propose adding or updating an entry in `learned-memories.mdc`:
   ```markdown
   ## Technical Decisions

   * **Async Runtime:** Tokio 1.28 is used due to compatibility issues with newer versions. Avoid using features introduced after 1.28.
   ```
4. In subsequent interactions involving tokio, the AI will refer to this entry and ensure compatibility with version 1.28.

## Memory File (`.cursor/rules/learned-memories.mdc`)

The basic structure:

```markdown
# RustPods Project Memory

This file stores project-specific knowledge, conventions, and user preferences learned by the AI assistant.

## User Preferences

- [Preference 1]
- [Preference 2]

## Technical Decisions

- [Decision 1]
- [Decision 2]

## Project Conventions

- [Convention 1]
- [Convention 2]

## Bluetooth Implementation Details

- [Detail 1]
- [Detail 2]
```
