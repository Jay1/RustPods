---
description:
globs:
alwaysApply: false
---
# Bluetooth Implementation Patterns

This document outlines the patterns and best practices for Bluetooth Low Energy (BLE) scanning and device interaction in the RustPods application.

## Bluetooth Scanner Implementation

- **BleScanner Structure**
  - Central class for managing Bluetooth operations
  - Handles adapter discovery, scanning, and device filtering
  ```rust
  // ✅ DO: Create a BleScanner struct with appropriate fields
  pub struct BleScanner {
      adapter: Option<Adapter>,
      event_broker: EventBroker<BleEvent>,
      config: ScanConfig,
      discovered_devices: HashMap<BDAddr, DiscoveredDevice>,
      scan_task: Option<JoinHandle<()>>,
      is_scanning: bool,
  }
  ```

- **Scanner Initialization**
  - Initialize the scanner with default or custom configuration
  - Discover and select the appropriate Bluetooth adapter
  ```rust
  // ✅ DO: Use this pattern for scanner initialization
  pub async fn initialize(&mut self) -> Result<(), BleError> {
      // Find an appropriate adapter
      if self.adapter.is_none() {
          let adapters = match AdapterManager::discover_adapters().await {
              Ok(adapters) => adapters,
              Err(e) => return Err(BleError::AdapterDiscoveryFailed(e.to_string())),
          };
          
          if adapters.is_empty() {
              return Err(BleError::AdapterNotFound);
          }
          
          // Use the first available adapter
          self.adapter = Some(adapters[0].adapter.clone());
      }
      
      Ok(())
  }
  ```

- **Scanning Operations**
  - Implement start/stop scanning methods
  - Use a background task for the actual scanning
  - Process BLE advertisements asynchronously
  ```rust
  // ✅ DO: Implement scanning with async tasks
  pub async fn start_scanning(&mut self) -> Result<mpsc::Receiver<BleEvent>, BleError> {
      if self.is_scanning {
          return Err(BleError::ScanInProgress);
      }
      
      // Create a receiver for events
      let receiver = self.event_broker.subscribe_all();
      
      // Create and start the scan task
      self.scan_task = Some(tokio::spawn(async move {
          // Scanning implementation
      }));
      
      self.is_scanning = true;
      
      Ok(receiver)
  }
  ```

## Bluetooth Event System

- **Event Types**
  - Define clear event types for Bluetooth operations
  - Use an enum to represent different event categories
  ```rust
  // ✅ DO: Define clear event types
  #[derive(Debug, Clone)]
  pub enum BleEvent {
      /// A new device was discovered during scanning
      DeviceDiscovered(DiscoveredDevice),
      /// A previously discovered device was lost
      DeviceLost(BDAddr),
      /// An error occurred during scanning or device interaction
      Error(String),
      /// Information about the Bluetooth adapter changed
      AdapterChanged(String),
      /// A scan cycle has completed
      ScanCycleCompleted { devices_found: usize },
      /// Scanning has completed (all cycles finished)
      ScanningCompleted,
      /// AirPods were detected
      AirPodsDetected(DetectedAirPods),
  }
  ```

- **Event Filtering**
  - Implement filtering to allow subscribers to receive only events they care about
  - Use predicates for custom filtering
  ```rust
  // ✅ DO: Create flexible event filtering
  #[derive(Clone)]
  pub struct EventFilter {
      predicate: Arc<dyn Fn(&BleEvent) -> bool + Send + Sync>,
  }
  
  impl EventFilter {
      /// Create an event filter that matches a specific type of event
      pub fn event_type(event_type: EventType) -> Self {
          Self::event_types(vec![event_type])
      }
      
      /// Create an event filter that matches any of the specified event types
      pub fn event_types(event_types: Vec<EventType>) -> Self {
          Self::custom(move |event| {
              let event_type = EventType::from(event);
              event_types.contains(&event_type)
          })
      }
      
      /// Create a custom event filter with a predicate function
      pub fn custom<F>(predicate: F) -> Self
      where
          F: Fn(&BleEvent) -> bool + Send + Sync + 'static,
      {
          Self {
              predicate: Arc::new(predicate),
          }
      }
  }
  ```

- **Event Broker**
  - Centralize event distribution to subscribers
  - Implement subscribe/unsubscribe functionality
  ```rust
  // ✅ DO: Create an event broker for distributing events
  pub struct EventBroker<T: Clone + Send + 'static> {
      subscribers: Arc<Mutex<HashMap<SubscriberId, (mpsc::Sender<T>, Option<EventFilter>)>>>,
      next_id: Arc<AtomicUsize>,
  }
  
  impl<T: Clone + Send + 'static> EventBroker<T> {
      pub fn new() -> Self {
          Self {
              subscribers: Arc::new(Mutex::new(HashMap::new())),
              next_id: Arc::new(AtomicUsize::new(1)),
          }
      }
      
      pub fn subscribe(&self, filter: EventFilter) -> mpsc::Receiver<T> {
          let (tx, rx) = mpsc::channel(100);
          let id = self.next_id.fetch_add(1, Ordering::SeqCst);
          
          self.subscribers.lock().unwrap().insert(id, (tx, Some(filter)));
          
          rx
      }
      
      pub fn subscribe_all(&self) -> mpsc::Receiver<T> {
          let (tx, rx) = mpsc::channel(100);
          let id = self.next_id.fetch_add(1, Ordering::SeqCst);
          
          self.subscribers.lock().unwrap().insert(id, (tx, None));
          
          rx
      }
      
      pub fn publish(&self, event: T) {
          let subscribers = self.subscribers.lock().unwrap();
          
          for (id, (tx, filter)) in subscribers.iter() {
              // Check if subscriber is still interested
              if tx.is_closed() {
                  continue;
              }
              
              // Check if event passes the filter
              if let Some(filter) = filter {
                  if !filter.matches(&event) {
                      continue;
                  }
              }
              
              // Clone the event for each subscriber
              let event_clone = event.clone();
              let tx_clone = tx.clone();
              
              // Send event asynchronously
              tokio::spawn(async move {
                  if let Err(_) = tx_clone.send(event_clone).await {
                      // Subscriber likely dropped the receiver
                  }
              });
          }
      }
  }
  ```

## Device Discovery and Filtering

- **Device Discovery**
  - Track discovered devices with their properties
  - Implement timeout for devices that haven't been seen recently
  ```rust
  // ✅ DO: Use this pattern for device discovery
  pub async fn handle_discovered_device(&mut self, peripheral: &Peripheral) {
      // Extract device information
      let address = peripheral.address();
      let properties = peripheral.properties().await.ok().flatten();
      
      // Update or create device entry
      if let Some(existing_device) = self.discovered_devices.get_mut(&address) {
          // Update existing device
          existing_device.last_seen = Instant::now();
          if let Some(props) = properties {
              if let Some(name) = props.local_name {
                  existing_device.name = Some(name);
              }
              existing_device.rssi = props.rssi;
              if !props.manufacturer_data.is_empty() {
                  existing_device.manufacturer_data = props.manufacturer_data;
              }
          }
          
          // Notify about device update
          self.event_broker.publish(BleEvent::DeviceUpdated(existing_device.clone()));
      } else {
          // Create new device
          let mut device = DiscoveredDevice {
              address,
              name: None,
              rssi: None,
              manufacturer_data: HashMap::new(),
              is_potential_airpods: false,
              last_seen: Instant::now(),
          };
          
          if let Some(props) = properties {
              device.name = props.local_name;
              device.rssi = props.rssi;
              device.manufacturer_data = props.manufacturer_data;
          }
          
          // Check if this might be AirPods
          device.is_potential_airpods = device.manufacturer_data
              .keys()
              .any(|id| *id == APPLE_COMPANY_ID);
          
          // Add to discovered devices
          self.discovered_devices.insert(address, device.clone());
          
          // Notify about new device
          self.event_broker.publish(BleEvent::DeviceDiscovered(device));
      }
  }
  ```

- **Device Filtering**
  - Create filters for specific device types
  - Implement AirPods-specific filtering
  ```rust
  // ✅ DO: Implement specific filters for device types
  pub fn get_filtered_airpods(&self, filter: &AirPodsFilter) -> Vec<DetectedAirPods> {
      // Start with all discovered devices
      let devices = self.discovered_devices.values()
          .filter(|d| d.is_potential_airpods)
          .cloned()
          .collect::<Vec<_>>();
      
      // Apply the AirPods filter
      let airpods = detect_airpods(devices);
      
      // Apply additional filtering criteria
      airpods.into_iter()
          .filter(|airpods| filter.matches(airpods))
          .collect()
  }
  ```

## AirPods-Specific Functionality

- **AirPods Detection**
  - Implement functions to identify AirPods from BLE advertisements
  - Extract manufacturer data for device identification
  ```rust
  // ✅ DO: Create AirPods detection functions
  pub fn detect_airpods(devices: Vec<DiscoveredDevice>) -> Vec<DetectedAirPods> {
      devices.into_iter()
          .filter_map(|device| {
              // Check if this is an Apple device
              let apple_data = device.manufacturer_data.get(&APPLE_COMPANY_ID)?;
              
              // Try to identify AirPods type from the data
              let device_type = identify_airpods_type(apple_data);
              if device_type == AirPodsType::Unknown {
                  return None;
              }
              
              // Parse battery information
              let battery = parse_airpods_data(apple_data).unwrap_or_default();
              
              Some(DetectedAirPods {
                  address: device.address,
                  name: device.name,
                  rssi: device.rssi,
                  device_type,
                  battery,
                  last_seen: device.last_seen,
              })
          })
          .collect()
  }
  ```

- **Battery Information Extraction**
  - Parse manufacturer data to extract battery levels
  - Normalize battery values to percentages
  ```rust
  // ✅ DO: Extract battery information from manufacturer data
  pub fn parse_airpods_data(data: &[u8]) -> Option<AirPodsBattery> {
      // Ensure we have enough data for parsing
      if data.len() < 16 {
          return None;
      }
      
      // Extract charging status information
      let charging_flags = if data.len() > 14 { data[14] } else { 0 };
      let charging = ChargingStatus {
          left: (charging_flags & 0x04) != 0,
          right: (charging_flags & 0x02) != 0,
          case: (charging_flags & 0x01) != 0,
      };
      
      // Extract battery levels and convert to percentages
      let left_battery = if data.len() > 12 {
          extract_battery_percentage(data[12])
      } else {
          None
      };
      
      let right_battery = if data.len() > 13 {
          extract_battery_percentage(data[13])
      } else {
          None
      };
      
      let case_battery = if data.len() > 15 {
          extract_battery_percentage(data[15])
      } else {
          None
      };
      
      Some(AirPodsBattery {
          left: left_battery,
          right: right_battery,
          case: case_battery,
          charging,
      })
  }
  ```

## Error Handling

- **Bluetooth Errors**
  - Define a comprehensive error type for Bluetooth operations
  - Use `thiserror` for clean error definitions
  ```rust
  // ✅ DO: Define clear error types
  #[derive(Debug, thiserror::Error)]
  pub enum BleError {
      #[error("Failed to find a suitable Bluetooth adapter")]
      AdapterNotFound,
      
      #[error("Failed to discover Bluetooth adapters: {0}")]
      AdapterDiscoveryFailed(String),
      
      #[error("Bluetooth operation failed: {0}")]
      BtlePlugError(#[from] btleplug::Error),
      
      #[error("Scanning is already in progress")]
      ScanInProgress,
      
      #[error("Device communication error: {0}")]
      DeviceError(String),
      
      #[error("Operation timeout")]
      Timeout,
  }
  ```

- **Error Propagation**
  - Properly propagate errors through the call stack
  - Convert between error types when crossing module boundaries
  ```rust
  // ✅ DO: Propagate errors appropriately
  pub async fn start_scanning(&mut self) -> Result<mpsc::Receiver<BleEvent>, BleError> {
      if self.is_scanning {
          return Err(BleError::ScanInProgress);
      }
      
      let adapter = match &self.adapter {
          Some(adapter) => adapter,
          None => return Err(BleError::AdapterNotFound),
      };
      
      // Start the adapter scanning
      adapter.start_scan(ScanFilter::default()).await
          .map_err(BleError::BtlePlugError)?;
      
      // Create a receiver for events
      let receiver = self.event_broker.subscribe_all();
      
      // Rest of implementation...
      
      Ok(receiver)
  }
  ```

## Testing Strategies

- **Mock Bluetooth Devices**
  - Create mock implementations for testing
  - Use dependency injection to substitute real adapters with mocks
  ```rust
  // ✅ DO: Use traits for testability
  #[cfg(test)]
  mod tests {
      use super::*;
      use mockall::predicate::*;
      use mockall::*;
      
      mock! {
          BluetoothAdapter {
              fn start_scan(&self) -> Result<(), MockError>;
              fn stop_scan(&self) -> Result<(), MockError>;
              fn get_devices(&self) -> Result<Vec<MockDevice>, MockError>;
          }
      }
      
      #[tokio::test]
      async fn test_scanner_start_stop() {
          let mut mock_adapter = MockBluetoothAdapter::new();
          
          // Set up expectations
          mock_adapter.expect_start_scan()
              .returning(|| Ok(()));
          
          mock_adapter.expect_stop_scan()
              .returning(|| Ok(()));
          
          // Create scanner with mock adapter
          let mut scanner = BleScanner::new();
          scanner.adapter = Some(Box::new(mock_adapter));
          
          // Test scanning
          let result = scanner.start_scanning().await;
          assert!(result.is_ok());
          
          let result = scanner.stop_scanning().await;
          assert!(result.is_ok());
      }
  }
  ```

- **Integration Tests**
  - Test the complete Bluetooth stack with real devices if possible
  - Fallback to recorded data for consistent test results
  ```rust
  // ✅ DO: Test with recorded data
  #[cfg(test)]
  mod integration_tests {
      use super::*;
      
      #[tokio::test]
      async fn test_airpods_detection_from_recorded_data() {
          // Sample manufacturer data from real AirPods
          let sample_data = [
              0x07, 0x19, 0x01, 0x02, 0x03, 0x04, 0x05, 
              0x06, 0x07, 0x08, 0x09, 0x0A, 0x08, 0x06, 
              0x05, 0x07
          ];
          
          // Create a device with this data
          let mut manufacturer_data = HashMap::new();
          manufacturer_data.insert(APPLE_COMPANY_ID, sample_data.to_vec());
          
          let device = DiscoveredDevice {
              address: BDAddr::from([1, 2, 3, 4, 5, 6]),
              name: Some("AirPods".to_string()),
              rssi: Some(-60),
              manufacturer_data,
              is_potential_airpods: true,
              last_seen: Instant::now(),
          };
          
          // Test AirPods detection
          let airpods = detect_airpods(vec![device]);
          
          assert_eq!(airpods.len(), 1);
          assert_eq!(airpods[0].device_type, AirPodsType::AirPods2);
          assert_eq!(airpods[0].battery.left, Some(80));
          assert_eq!(airpods[0].battery.right, Some(60));
          assert_eq!(airpods[0].battery.case, Some(70));
      }
  }
  ```
