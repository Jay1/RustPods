---
description: 
globs: 
alwaysApply: true
---
# Project Structure Guidelines

## Directory Layout

- **Root Structure:**
  - Keep the root directory clean and organized
  - Place source code in `src/`
  - Place tests in `tests/`
  - Configuration in appropriate config files
  - Documentation in `docs/`

- **Source Structure:**
  ```
  src/
  ├── main.rs           // Application entry point
  ├── lib.rs            // Library exports
  ├── app/              // Main application logic
  │   └── mod.rs  
  ├── bluetooth/        // Bluetooth functionality
  │   ├── mod.rs
  │   ├── scanner.rs
  │   ├── scanner_config.rs
  │   ├── adapter.rs
  │   └── examples.rs
  ├── airpods/          // AirPods-specific parsing and logic
  │   ├── mod.rs
  │   └── detector.rs
  ├── ui/               // User interface components
  │   ├── mod.rs
  │   ├── app.rs
  │   ├── components/
  │   │   ├── settings_view.rs
  │   │   └── ...
  │   ├── state.rs      // Application state management
  │   ├── message.rs    // UI message types
  │   ├── theme.rs      // Theming and styling
  │   ├── main_window.rs // Main application window
  │   ├── settings_window.rs // Settings UI window
  │   ├── system_tray.rs // System tray integration
  │   └── ...
  ├── config/           // Application configuration
  │   ├── mod.rs
  │   └── app_config.rs // Configuration types and persistence
  └── error.rs          // Error types
  ```

- **Tests Structure:**
  ```
  tests/
  ├── app_config_tests.rs     // Configuration tests
  ├── bluetooth_tests.rs      // Bluetooth functionality tests
  ├── airpods_tests.rs        // AirPods detection tests
  ├── config_tests.rs         // Other configuration tests
  ├── settings_window_tests.rs // Settings UI window tests
  └── ...
  ```

## Module Organization

- **Main Module Pattern:**
  - Each primary module should have a `mod.rs` file
  - Use `mod.rs` for re-exports and module documentation
  - Separate distinct functionality into individual files
  ```rust
  // src/ui/mod.rs
  //! UI module for the application

  // Module exports
  mod app;
  pub mod components;
  pub mod state;
  mod message;
  mod system_tray;
  mod main_window;
  mod settings_window;
  pub mod theme;

  // Re-exports for easier access
  pub use app::{run_ui, view, subscription};
  pub use state::AppState;
  pub use message::Message;
  pub use system_tray::SystemTray;
  pub use main_window::MainWindow;
  pub use settings_window::{SettingsWindow, SettingsTab};

  /// Trait for UI components that can be rendered
  pub trait UiComponent {
      /// Convert the component to an element
      fn view(&self) -> iced::Element<'static, Message, iced::Renderer<theme::Theme>>;
  }
  ```

- **Component Organization:**
  - Group related components in dedicated modules
  - Re-export components for easier access
  ```rust
  // src/ui/components/mod.rs
  //! UI components module

  mod settings_view;
  
  pub use settings_view::{
      SettingsView, BluetoothSetting, UiSetting, SystemSetting
  };
  ```

## Code Organization

- **File Structure:**
  - Start files with documentation comments
  - Place imports at the top, grouped by source
  - Define public types first
  - Place implementation blocks after type definitions
  - Place tests in a `#[cfg(test)]` module at the end of the file
  ```rust
  //! Settings window implementation for RustPods

  use crate::config::AppConfig;
  use crate::ui::Message;
  use crate::ui::theme::{self, Theme};
  use crate::ui::UiComponent;
  
  /// Represents the settings window of the application
  #[derive(Debug)]
  pub struct SettingsWindow {
      // Fields...
  }
  
  impl SettingsWindow {
      // Methods...
  }
  
  #[cfg(test)]
  mod tests {
      // Tests...
  }
  ```

- **Error Handling:**
  - Use `thiserror` for defining error types
  - Create specific error enums for modules
  - Use `Result<T, E>` for functions that can fail
  ```rust
  #[derive(Debug, thiserror::Error)]
  pub enum ConfigError {
      #[error("IO error: {0}")]
      IoError(#[from] std::io::Error),
      
      #[error("Serialization error: {0}")]
      SerializationError(#[from] serde_json::Error),
      
      #[error("Validation failed for {0}: {1}")]
      ValidationFailed(String, String),
  }
  ```

## Naming Conventions

- **General Naming:**
  - Use clear, descriptive names
  - Follow Rust naming conventions
  - Use snake_case for files (e.g., `settings_window.rs`)
  - Use snake_case for variables and functions
  - Use PascalCase for types and traits
  - Use SCREAMING_SNAKE_CASE for constants

- **Module Names:**
  - Use singular nouns for modules (e.g., `config`, not `configs`)
  - Use descriptive names that indicate functionality

- **Component Names:**
  - Name UI components based on their purpose
  - Use PascalCase for component structs
  - Examples: `SettingsWindow`, `MainWindow`, `SystemTray`

- **Message Types:**
  - Use descriptive names for message variants
  - Group related messages together
  - Example: `Message::UpdateBluetoothSetting(BluetoothSetting)`

## Documentation

- **Documentation Comments:**
  - Use `//!` for module-level documentation
  - Use `///` for item-level documentation
  - Document all public APIs
  - Include examples where appropriate
  ```rust
  //! Settings window implementation for RustPods
  
  /// Represents the settings window of the application
  #[derive(Debug)]
  pub struct SettingsWindow {
      /// Application configuration
      config: AppConfig,
      /// Whether changes have been made
      has_changes: bool,
  }
  ```

- **Code Comments:**
  - Comment complex algorithms or non-obvious code
  - Keep comments current with code changes
  - Use TODO, FIXME, or NOTE for temporary comments
  - Avoid unnecessary comments for self-documenting code

## Testing Structure

- **Unit Tests:**
  - Place unit tests in the same file as the code being tested
  - Use `#[cfg(test)]` module at the end of the file
  - Follow standard naming conventions for test functions
  ```rust
  #[cfg(test)]
  mod tests {
      use super::*;
      
      #[test]
      fn test_mark_changed() {
          let mut window = SettingsWindow::new(AppConfig::default());
          assert!(!window.has_changes());
          window.mark_changed();
          assert!(window.has_changes());
      }
  }
  ```

- **Integration Tests:**
  - Place integration tests in the `tests/` directory
  - Organize by functionality
  - Group related tests in dedicated files
  ```
  tests/
  ├── app_config_tests.rs     // Tests for AppConfig
  ├── settings_window_tests.rs // Tests for SettingsWindow
  ```

## Cross-Platform Considerations

- **Platform-Specific Code:**
  - Use conditional compilation for platform-specific code
  - Keep platform-specific code isolated
  ```rust
  #[cfg(target_os = "windows")]
  fn set_autostart_enabled(enabled: bool) -> Result<(), ConfigError> {
      // Windows-specific implementation
  }
  
  #[cfg(target_os = "macos")]
  fn set_autostart_enabled(enabled: bool) -> Result<(), ConfigError> {
      // macOS-specific implementation
  }
  ```

- **Bluetooth Considerations:**
  - Handle platform-specific Bluetooth quirks
  - Windows is the primary target platform
  - Ensure adapter management works across supported platforms
  - Use feature flags for optional platform support
  - Test adapter discovery and scanning on all platforms

## UI Component Organization

- **Component Hierarchy:**
  - Base components should be reusable and composable
  - More complex components should build on simpler ones
  - Separate presentation from logic where possible
  - Use a consistent style throughout the application

- **State Management:**
  - Use `AppState` as the single source of truth
  - Pass down configuration via props/parameters
  - Update state through messages
  - Keep UI components as functional as possible

- **Settings Organization:**
  - Group settings by category (Bluetooth, UI, System)
  - Use appropriate UI controls for different setting types
  - Implement validation for user input
  - Provide clear feedback on validation errors

## Asynchronous Code Organization

- **Tokio for Async Operations:**
  - Use tokio for all async operations
  - Create separate async functions for distinct operations
  - Use channels for communication between async tasks
  ```rust
  // In BleScanner
  pub async fn start_scanning(&mut self) -> Result<Receiver<BleEvent>, BleError> {
      // Initialize scanning...
      
      // Create channels for communication
      let (tx, rx) = channel(100);
      self.event_sender = Some(tx.clone());
      
      // Start scanning task
      let scan_task = self.start_scan_task(tx, cancel_rx).await?;
      self.scan_task = Some(scan_task);
      
      Ok(rx)
  }
  ```

- **Task Management:**
  - Keep track of active tasks with JoinHandle
  - Properly clean up tasks when they're no longer needed
  - Use Arc/Mutex for shared state across tasks
  ```rust
  impl Drop for SomeAsyncComponent {
      fn drop(&mut self) {
          // Abort the background task if still running
          if let Some(task) = self.task.take() {
              task.abort();
          }
      }
  }
  ```

## UI Theme Organization

- **Theme Module Structure:**
  - Define color constants at the top of the module
  - Group related colors together (base colors, text colors, accent colors)
  - Use semantic naming for colors (e.g., TEXT, BACKGROUND, ACCENT)
  - Implement styling for all widget components consistently
  ```rust
  // Example theme module structure
  //! Theme module for application styling
  
  use iced::{Color, application, widget::{button, container, text_input}};
  
  // Color constants
  pub const TEXT: Color = Color::from_rgb8(0xcd, 0xd6, 0xf4);
  pub const BACKGROUND: Color = Color::from_rgb8(0x1e, 0x1e, 0x2e);
  
  // Theme enum
  #[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
  pub enum Theme {
      #[default]
      CatppuccinMocha,
  }
  
  // Style implementations for various components
  impl application::StyleSheet for Theme { /* ... */ }
  impl button::StyleSheet for Theme { /* ... */ }
  impl container::StyleSheet for Theme { /* ... */ }
  impl text_input::StyleSheet for Theme { /* ... */ }
  ```

- **Theme Integration:**
  - Set the application theme in the main Application implementation
  - Override the theme() method to return the appropriate theme
  - Ensure consistent styling across all components
  ```rust
  impl Application for AppState {
      type Theme = crate::ui::theme::Theme;
      // ...
      
      fn theme(&self) -> Self::Theme {
          crate::ui::theme::Theme::CatppuccinMocha
      }
  }
  ```



