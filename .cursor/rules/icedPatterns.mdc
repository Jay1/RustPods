---
description: Guidelines for using the Iced GUI framework, covering application structure, message-based architecture, component organization, styling, and version-specific patterns
globs: 
alwaysApply: false
---
# Iced Framework Patterns

## Core Architecture

- **Application Structure**
  - Iced applications use a message-based architecture with state, messages, and views
  - State is a central struct that holds all application data
  - Messages are enums that represent events that can update the state
  - Views are functions that convert state into UI elements
  - Applications should follow the Model-View-Update (MVU) pattern

- **Running the UI Application**
  ```rust
  // ✅ DO: Use the iced::run function with title, update, and view functions
  pub fn run_ui() -> Result<(), iced::Error> {
      iced::run(
          "Application Title",
          update,
          view,
      )
  }
  
  // ❌ DON'T: Use the older Application trait directly
  // impl Application for AppState { ... }
  ```

- **Update Logic Structure**
  ```rust
  // ✅ DO: Use a separate update function with &mut State and Message parameters
  fn update(state: &mut AppState, message: Message) -> Command<Message> {
      match message {
          Message::ButtonPressed => {
              // Update state
              Command::none()
          }
      }
  }
  
  // ❌ DON'T: Try to use an update method on a state struct
  // impl AppState {
  //     fn update(&mut self, message: Message) -> Command<Message> { ... }
  // }
  ```

- **View Logic Structure**
  ```rust
  // ✅ DO: Use a separate view function that returns Element<Message>
  fn view(state: &AppState) -> Element<Message> {
      column![
          text("Hello, World!"),
          button("Click me").on_press(Message::ButtonPressed)
      ]
      .padding(20)
      .into()
  }
  
  // ❌ DON'T: Use a view method on a state struct directly in run_ui
  // impl AppState {
  //     fn view(&self) -> Element<Message> { ... }
  // }
  ```

## Component Organization

- **UI Component Trait**
  - Define a common trait for all UI components
  - Ensures consistent view method signatures
  - Helps with composition and reuse
  ```rust
  // ✅ DO: Create a UI component trait
  pub trait UiComponent {
      /// Render the component
      fn view(&self) -> iced::Element<'_, Message>;
  }
  
  // Implement the trait for components
  impl UiComponent for MyComponent {
      fn view(&self) -> Element<'_, Message> {
          // Component-specific view logic
      }
  }
  ```

- **Component Module Structure**
  - Organize components in a modular structure
  - Group related components in their own modules
  - Re-export components for easier imports
  - Follow this structure:
  ```
  src/ui/
  ├── mod.rs           // Main UI module, exports
  ├── app.rs           // Application entry point
  ├── message.rs       // UI message types
  ├── state.rs         // State management
  ├── components/      // UI components
  │   ├── mod.rs       // Components module
  │   ├── header.rs    // Individual component
  │   └── ...          // Other components
  └── ...              // Other UI-related modules
  ```

- **Component Example**
  ```rust
  // ✅ DO: Create focused, single-responsibility components
  // src/ui/components/battery_display.rs
  pub struct BatteryDisplay {
      left_level: Option<u8>,
      right_level: Option<u8>,
      case_level: Option<u8>,
  }
  
  impl UiComponent for BatteryDisplay {
      fn view(&self) -> Element<'_, Message> {
          column![
              // Component view logic
          ]
          .into()
      }
  }
  ```

## Element Type Handling and Testing

- **Proper Element Type Signatures**
  - Always specify the complete Element type with lifetime, message type, and renderer
  - Include the theme type when using themed renderers
  ```rust
  // ✅ DO: Use the full Element type signature
  fn view(&self) -> Element<'static, Message, iced::Renderer<Theme>> {
      // Component view logic
      text("Component").into()
  }
  
  // ❌ DON'T: Use incomplete Element types
  // fn view(&self) -> Element<Message> { ... }
  ```

- **Container Type Conversion**
  - Be careful when chaining method calls with `.into()`
  - For complex containers, explicitly cast to the target Element type
  ```rust
  // ✅ DO: Specify Element type when chaining container methods
  container(content)
      .width(Length::Fill)
      .padding(10)
      .into() as Element<'static, Message, iced::Renderer<Theme>>
  
  // ✅ ALTERNATIVELY: Simplify test implementations
  // In test implementations, you can return simple text elements
  text("Component").into()
  ```

- **Testing UI Components**
  - In tests, use simplified view implementations that don't use complex containers
  - Ensure your test code renders valid Element types
  - When testing components, focus on the component's logical behavior rather than its visual appearance
  ```rust
  // ✅ DO: Create simplified view implementations for tests
  #[cfg(test)]
  impl UiComponent for TestComponent {
      fn view(&self) -> Element<'static, Message, iced::Renderer<Theme>> {
          // Simple placeholder for tests
          text("Test Component").into()
      }
  }
  
  // ✅ DO: Write tests focusing on component logic, not rendering details
  #[test]
  fn test_component_behavior() {
      let component = MyComponent::new(10);
      assert_eq!(component.value, 10);
      
      // Verify the view can be called without errors
      let _element = component.view();
  }
  ```

- **Integration Test Patterns**
  - When testing state updates that affect UI, verify the state changes but not the rendered output
  - For event handling tests, check that the state responds correctly to events
  ```rust
  // ✅ DO: Verify state changes in integration tests
  #[test]
  fn test_start_stop_scan() {
      let mut state = AppState::default();
      
      // Check that we start scanning correctly
      assert!(!state.is_scanning);
      let _ = state.update(Message::StartScan);
      assert!(state.is_scanning);
      
      // Check that we stop scanning correctly
      let _ = state.update(Message::StopScan);
      assert!(!state.is_scanning);
  }
  ```

## State Management

- **Central State Struct**
  - Use a single `AppState` struct to hold application state
  - Provide methods for updating state in consistent ways
  - Keep state immutable except in update functions
  ```rust
  // ✅ DO: Create a central state struct with helper methods
  pub struct AppState {
      pub visible: bool,
      pub is_scanning: bool,
      pub devices: HashMap<String, DiscoveredDevice>,
      pub selected_device: Option<String>,
  }
  
  impl AppState {
      pub fn update_device(&mut self, device: DiscoveredDevice) {
          let address = device.address.to_string();
          self.devices.insert(address, device);
      }
      
      pub fn select_device(&mut self, address: String) {
          if self.devices.contains_key(&address) {
              self.selected_device = Some(address);
          }
      }
  }
  ```

- **Accessing State in View Functions**
  - Use helper methods to access and transform state data for views
  - Avoid complex logic in view functions
  ```rust
  // ✅ DO: Create methods to access state in a structured way
  impl AppState {
      pub fn get_selected_device(&self) -> Option<&DiscoveredDevice> {
          self.selected_device.as_ref().and_then(|addr| self.devices.get(addr))
      }
  }
  
  // In view function
  let battery_display = if let Some(device) = state.get_selected_device() {
      // Create component
  } else {
      // Create empty component
  };
  ```

## Widget Usage

- **Container Styling**
  - Use `container::Style` for styling containers
  - Apply consistent styles across similar components
  ```rust
  // ✅ DO: Use container::Style methods
  let styled_container = if is_selected {
      container(btn).padding(5).style(container::Style::primary())
  } else {
      container(btn).padding(5)
  };
  
  // For custom styles:
  container(header_row)
      .width(Length::Fill)
      .style(container::Style::custom(|_| {
          container::Appearance {
              text_color: None,
              background: Some(iced::Color::from_rgb(0.9, 0.9, 0.9).into()),
              border_radius: 5.0,
              border_width: 1.0,
              border_color: iced::Color::from_rgb(0.7, 0.7, 0.7),
          }
      }))
  ```

- **Button Styling**
  - Create styled buttons with consistent appearances
  - Use readable helper functions for common button styles
  ```rust
  // ✅ DO: Create buttons with appropriate styling
  let scan_button = if self.is_scanning {
      button("Stop Scan")
          .on_press(Message::StopScan)
  } else {
      button("Start Scan")
          .on_press(Message::StartScan)
  };

  // Wrap in a container for styling
  let styled_scan_button = if self.is_scanning {
      container(scan_button).style(container::Style::destructive())
  } else {
      container(scan_button).style(container::Style::primary())
  };
  ```

- **Layout Best Practices**
  - Use Length::Fill, Length::FillPortion, and Length::Shrink appropriately
  - Apply consistent padding and spacing
  - Use nested containers for complex layouts
  ```rust
  // ✅ DO: Create well-structured layouts
  row![
      text(device_name).width(Length::FillPortion(3)),
      text(device_type).width(Length::FillPortion(2)),
      text(rssi).width(Length::FillPortion(1)),
  ]
  .spacing(10)
  .padding(5)
  ```

## System Tray Integration

- **System Tray Structure**
  - Use the `tray-item` crate for system tray functionality
  - Create a dedicated struct for system tray management
  - Implement error handling for tray operations
  ```rust
  // ✅ DO: Create a dedicated SystemTray struct
  pub struct SystemTray {
      tray: TrayItem,
      tx: mpsc::Sender<Message>,
  }
  
  impl SystemTray {
      pub fn new(tx: mpsc::Sender<Message>) -> Result<Self, SystemTrayError> {
          let mut tray = TrayItem::new("AppName", "default")
              .map_err(|e| SystemTrayError::Creation(e.to_string()))?;
          
          // Add menu items
          let tx_clone = tx.clone();
          tray.add_menu_item("Open", move || {
              let _ = tx_clone.send(Message::ToggleVisibility);
          })
          .map_err(|e| SystemTrayError::MenuItem(e.to_string()))?;
          
          // More menu items...
          
          Ok(Self { tray, tx })
      }
      
      pub fn update_icon(&mut self, connected: bool) -> Result<(), SystemTrayError> {
          let icon = if connected { "connected" } else { "default" };
          self.tray.set_icon(icon)
              .map_err(|e| SystemTrayError::SetIcon(e.to_string()))
      }
  }
  ```

## RustPods-Specific Patterns

- **Sandbox Implementation**
  - RustPods uses the `Sandbox` trait for the main application
  - The `AppState` struct implements the `Sandbox` trait
  - A separate `run_ui` function in `ui/app.rs` launches the application
  ```rust
  // ✅ DO: Use this pattern for launching the UI
  // In src/ui/app.rs
  pub fn run_ui() -> iced::Result {
      use iced::Sandbox;
      AppState::run(Settings::default())
  }

  // In src/ui/state.rs
  impl Sandbox for AppState {
      type Message = Message;
      
      fn new() -> Self {
          Self::default()
      }
      
      fn title(&self) -> String {
          String::from("RustPods")
      }
      
      fn update(&mut self, message: Message) {
          // Message handling
      }
      
      fn view(&self) -> iced::Element<Message> {
          // View rendering, often delegated to a separate function
          crate::ui::app::view(self)
      }
  }
  ```

- **UI Component Structure**
  - All UI components are in the `ui/components` directory
  - Each component is in its own file
  - Components include:
    - `device_list`: Displays a list of discovered devices
    - `battery_display`: Shows battery levels for AirPods
    - `header`: Application header with controls

- **Event System Integration**
  - Bluetooth events are translated to UI messages
  - Events flow from the `BleScanner` to `AppState` to UI components
  - Use the `Message` enum to represent UI events:
  ```rust
  // ✅ DO: Define messages for all UI events
  pub enum Message {
      ToggleVisibility,
      Exit,
      DeviceDiscovered(DiscoveredDevice),
      DeviceUpdated(DiscoveredDevice),
      SelectDevice(String),
      StartScan,
      StopScan,
      ToggleAutoScan(bool),
      Tick,
  }
  ```

- **Command-line Interface Integration**
  - The UI is launched with a specific command: `rustpods ui`
  - The application can still function in CLI mode with other commands
  - The entry point in `main.rs` handles command-line arguments and routing

- **View Structure**
  - The main view is created in `ui/app.rs`
  - Views are composed of smaller components
  - Basic structure:
  ```rust
  pub fn view(state: &AppState) -> Element<Message> {
      // Simple MVP view for now
      let content = column![
          text("RustPods").size(30),
          text("AirPods Battery Monitor").size(20),
          text("MVP Version").size(16),
      ].spacing(10);
      
      container(content)
          .width(iced::Length::Fill)
          .height(iced::Length::Fill)
          .padding(20)
          .center_x()
          .center_y()
          .into()
  }
  ```

- **Project Configuration Integration**
  - UI components access configuration via `AppState`
  - The UI should reflect current configuration settings
  - Configuration changes should be persisted

## Reference and Ownership Management

- **Handling Temporary Value References**
  - Be careful with references to temporary values in view methods
  - Ensure component views don't return references to local variables created within the view method
  - Common error: "cannot return value referencing temporary value"
  ```rust
  // ❌ DON'T: Return references to temporary values
  fn view(&self) -> Element<'_, Message, iced::Renderer<Theme>> {
      // The 'status' is a temporary local variable
      let status = ConnectionStatus::new(
          self.is_connected,
          self.is_scanning
      );
      
      // PROBLEM: This returns a reference to 'status' which won't 
      // live beyond this function
      status.view()
  }
  ```

- **Wrapper Component Pattern**
  - Create wrapper components that own their data and return owned Elements
  - Use render() methods that don't return references to self
  - Implement From trait for Element to allow direct use in macros
  ```rust
  // ✅ DO: Create wrapper components that own their data
  #[derive(Debug, Clone)]
  pub struct ConnectionStatusWrapper {
      pub is_connected: bool,
      pub is_scanning: bool,
      pub animation_progress: f32,
  }
  
  impl ConnectionStatusWrapper {
      // Method that renders directly to an owned Element
      pub fn render(&self) -> Element<'static, Message, iced::Renderer<Theme>> {
          // Create a fully owned representation, no borrowing of 'self'
          let text = if self.is_connected { "Connected" } else { "Disconnected" };
          text(text).into()
      }
  }
  
  impl UiComponent for ConnectionStatusWrapper {
      fn view(&self) -> Element<'_, Message, iced::Renderer<Theme>> {
          self.render()
      }
  }
  
  // Allow direct use in column! and other macros
  impl<'a> From<ConnectionStatusWrapper> for Element<'a, Message, iced::Renderer<Theme>> {
      fn from(wrapper: ConnectionStatusWrapper) -> Self {
          wrapper.render()
      }
  }
  ```

- **Component Composition Best Practices**
  - Create components that are self-contained and own their data
  - Use component composition rather than complex rendering logic
  - Pass data to components rather than sharing references
  ```rust
  // ✅ DO: Prefer component composition with owned data
  impl UiComponent for MainWindow {
      fn view(&self) -> Element<'_, Message, iced::Renderer<Theme>> {
          let header = self.create_header();
          
          // Use a component that owns its data, 
          // avoiding temporary value reference issues
          let connection_status = ConnectionStatusWrapper::new(
              self.selected_device.is_some(),
              self.is_scanning
          )
          .with_animation_progress(self.animation_progress);
          
          column![
              header,
              connection_status,  // Implicitly converted to Element
              iced::widget::Space::new(Length::Fill, Length::Fixed(20.0)),
              self.view_content()
          ]
          .into()
      }
  }
  ```

- **Helper Method Pattern**
  - Create helper methods that return owned Elements for complex UI sections
  - Use proper method signatures with explicit lifetimes
  - Compose larger views from smaller helper methods
  ```rust
  // ✅ DO: Create helper methods for view sections
  impl MainWindow {
      // Helper method to create a section of the UI
      fn create_header(&self) -> Element<'_, Message, iced::Renderer<Theme>> {
          column![
              text("RustPods")
                  .size(30)
                  .horizontal_alignment(Horizontal::Center),
              iced::widget::Space::new(Length::Fill, Length::Fixed(10.0)),
          ]
          .width(Length::Fill)
          .align_items(iced::Alignment::Center)
          .into()
      }
      
      fn view_content(&self) -> Element<'_, Message, iced::Renderer<Theme>> {
          if let Some(device) = &self.selected_device {
              self.render_connected_device(device)
          } else {
              self.render_device_list()
          }
      }
  }
  ```



