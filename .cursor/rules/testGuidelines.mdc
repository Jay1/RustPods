---
description: This document outlines our test-driven approach for the RustPods project, covering unit tests. This document outlines our test-driven approach for the RustPods project, covering unit tests, integration tests, and UI component testing patternsgration tests, and UI component testing patterns
globs: 
alwaysApply: false
---
# Testing Guidelines for the RustPods Project

This document outlines our testing approach for ensuring RustPods is reliable and stable. It covers unit tests, integration tests, and UI component testing patterns.

## Core Principles

- **Test-Driven Development**: Write tests before implementing features when possible.
- **Comprehensive Coverage**: Aim for high test coverage, especially for core functionality.
- **Isolation**: Unit tests should focus on testing a single component with minimal dependencies.
- **Mock Integration**: Use mocks and test doubles when testing components that have external dependencies.
- **Error Handling**: Test both success and failure cases, ensuring proper error handling.
- **Test Readability**: Write clear, self-documenting tests with descriptive names.

## Directory Structure

```
project_root/
├── src/
│   └── module_name/
│       ├── mod.rs
│       ├── implementation.rs
│       └── tests.rs         # Unit tests for this module
├── tests/
│   ├── common_test_helpers.rs  # Shared test utilities
│   ├── integration/
│   │   └── specific_test.rs    # Integration tests
│   ├── bluetooth/             # Bluetooth-specific tests
│   ├── ui/                    # UI-specific tests
│   │   ├── theme_tests.rs     # Theme-specific tests
│   │   └── ...
│   └── app_config_tests.rs    # Config-specific tests
```

## Test Types

### Unit Tests

- **Location**: Inside the module being tested (in a `tests` module)
- **Purpose**: Test individual functions and methods in isolation
- **Example**:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_parse_airpods_data_empty() {
        let data = vec![1, 2, 3];
        let result = parse_airpods_data(&data);
        assert!(result.is_none());
    }
}
```

### Integration Tests

- **Location**: In the `tests/` directory
- **Purpose**: Test interaction between components or across module boundaries
- **Example**:

```rust
#[test]
fn test_app_state_defaults() {
    let state = AppState::default();
    
    // Check initial state
    assert!(!state.visible);
    assert!(!state.is_scanning);
    assert!(state.auto_scan);
    assert!(state.devices.is_empty());
    assert_eq!(state.selected_device, None);
}
```

### UI Component Tests

- **Unit Test Location**: Place unit tests for UI components directly within their respective source files (e.g., `src/ui/components/my_component.rs`) inside a `#[cfg(test)] mod tests { ... }` block.
- **Integration Test Location**: For tests that verify interactions between multiple UI components or a component with the broader UI state, use integration tests in the main `tests/ui/` directory.
- **Purpose**: Verify UI components render correctly and handle events properly
- **Example**:

```rust
// src/ui/components/device_list.rs
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_device_list_renders() {
        // ...
    }
}
```

```rust
// tests/ui/device_list_integration.rs
#[test]
fn test_device_list_with_state_changes() {
    // ...
}
```

### Theme Tests

- **Unit Test Location**: Place theme unit tests in `src/ui/theme.rs` inside the `#[cfg(test)] mod tests { ... }` block.
- **Integration Test Location**: For theme integration tests, use `tests/ui/theme_tests.rs`.
- **Purpose**: Verify theme colors, styling implementations, and proper application to UI components.
- **Patterns**:
  - Test color constants match expected values
  - Test theme implementations (StyleSheet traits)
  - Test theme application to components
  - Test theme changes (if theme switching is supported)
- **Example**:

```rust
// src/ui/theme.rs
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_theme_color_constants() {
        // Test that color constants match expected values
        assert_eq!(TEXT, Color::from_rgb8(0xcd, 0xd6, 0xf4));
        assert_eq!(BASE, Color::from_rgb8(0x1e, 0x1e, 0x2e));
    }
    
    #[test]
    fn test_application_style() {
        let theme = Theme::CatppuccinMocha;
        let appearance = <Theme as application::StyleSheet>::appearance(&theme, &());
        
        assert_eq!(appearance.background_color, BASE);
        assert_eq!(appearance.text_color, TEXT);
    }
}
```

```rust
// tests/ui/theme_tests.rs
#[test]
fn test_theme_integration() {
    // Test that the theme is properly applied to components
    let app_state = AppState::default();
    assert_eq!(app_state.theme(), theme::Theme::CatppuccinMocha);
    
    // Test that components render with the correct styling
    // ...
}
```

## Mock Objects

- Use the `mockall` crate for creating mock objects for testing
- Create mocks for external dependencies like Bluetooth peripherals
- Carefully control mock behavior for deterministic tests

```rust
// Example mock for a Bluetooth device
#[automock]
trait BluetoothDevice {
    fn connect(&mut self) -> Result<(), Error>;
    fn read_battery(&self) -> Result<u8, Error>;
}
```

## Test Utilities

- `tests/common_test_helpers.rs` contains shared test utilities.
- Use these helpers to simplify test setup and reduce duplication across multiple tests, particularly integration tests.
- **Note on Scope**: For unit tests, prefer defining test-specific helpers within the `#[cfg(test)] mod tests {}` block of the module under test if the helpers are not broadly applicable across different modules or integration tests. This promotes better isolation. For helpers shared across multiple integration tests or complex unit test setups that genuinely benefit from shared code, `tests/common_test_helpers.rs` is appropriate.
- Include helper functions for:
  - Creating test device objects
  - Setting up mock behaviors
  - Handling async test utilities (e.g., custom functions like `receiver_with_timeout(receiver, duration)` for managing timeouts with `tokio::sync::mpsc::Receiver` or similar async primitives in tests)
  - Creating test configuration objects
  - Creating test UI elements with specific themes

```rust
// Example test helper
pub fn create_test_airpods() -> DetectedAirPods {
    DetectedAirPods {
        address: BDAddr::from([0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC]),
        name: Some("AirPods Pro".to_string()),
        device_type: AirPodsType::AirPodsPro,
        battery: AirPodsBattery::default(),
        rssi: Some(-60),
        raw_data: vec![0x0E, 0x19, 0x01, 0x02, 0x03],
    }
}

// Example theme test helper
pub fn create_test_ui_with_theme() -> (iced::Settings<()>, AppState) {
    let settings = iced::Settings {
        flags: (),
        antialiasing: true,
        ..Default::default()
    };
    
    let state = AppState::default();
    
    (settings, state)
}
```

## Asynchronous Testing

- Use `tokio::test` for async tests
- Set appropriate timeouts to prevent test hangs
- Use channels for simulating async events
- Handle proper cleanup in async tests

```rust
#[tokio::test]
async fn test_scanner_events() {
    let mut scanner = BleScanner::new().await.unwrap();
    let (tx, rx) = channel::<BleEvent>(10);
    
    // Test async operation
    let scan_task = tokio::spawn(async move {
        // Test code...
    });
    
    // Always clean up the task
    scan_task.abort();
}
```

## Configuration Tests

- **Location**: `tests/app_config_tests.rs`
- **Purpose**: Verify config loading, saving, and validation
- **Patterns**:
  - Use tempdir for file I/O tests
  - Test data serialization/deserialization
  - Verify default values
  - Test validation logic works correctly

## Common Pitfalls and Test Failures

- **Accessing Nested Configuration Fields:** When working with structured configuration objects, ensure you access nested fields correctly (e.g., `config.bluetooth.scan_duration`) rather than attempting to access them directly from the top-level config object if they are not defined there (e.g., `config.scan_duration` when `scan_duration` is actually under `bluetooth`). Incorrect pathing is a common source of errors or `None` values in tests. Double-check the structure of your configuration objects and access fields accordingly.

## UI State Testing 

- **Location**: `tests/ui/state.rs`
- **Purpose**: Verify application state updates correctly
- **Patterns**:
  - Test message handling
  - Verify state transitions
  - Test UI model business logic
  - Ensure proper UI updates on state changes

## Bluetooth Tests

- **Unit Test Location**: Place unit tests within the respective source file (e.g., `src/bluetooth/your_component.rs`) inside a `#[cfg(test)] mod tests { ... }` block.
- **Integration Test Location**: Integration tests for Bluetooth functionality go into `tests/bluetooth/`.
- **Purpose**: Test all Bluetooth functionality
- **Patterns**:
  - Mock BLE devices for testing without hardware
  - Test filtering and device detection
  - Test connection management
  - Test battery status extraction
  - Test events properly propagate through the system

## Test Naming Conventions

- Use descriptive test names that explain what is being tested
- Follow the pattern `test_<function>_<scenario>_<expected_outcome>`
- Examples:
  - `test_parse_airpods_data_empty_returns_none`
  - `test_scan_with_invalid_adapter_fails`
  - `test_battery_status_extraction_from_manufacturer_data`

## Tips for Writing Good Tests

- **Arrange-Act-Assert**: Structure tests with setup, action, and verification phases
- **Independent Tests**: Each test should be able to run independently
- **Descriptive Assert Messages**: Include messages in assertions to explain failures
- **Test Edge Cases**: Include tests for empty/null values, large numbers, etc.
- **Test Performance**: Ensure tests run quickly, especially unit tests
- **Avoid Test Interdependence**: Don't let tests depend on each other's state

## Running Tests

- **Run all tests:** `cargo test`
- **Run a single test by name:** `cargo test test_name`
- **Run all tests in a specific file:** `cargo test --test file_name`
  - Note: This targets a specific integration test file (e.g., `tests/file_name.rs`) or files starting with that name
- **Run tests in a subdirectory:**
  - For tests organized in subdirectories (e.g., `tests/ui/`), you have several options:
  - **By module path:** `cargo test ui::` (runs all tests in modules with path starting with "ui::")
  - **By name pattern:** `cargo test ui_` (runs all test functions whose names start with "ui_")
  - **By individual test binary:** For each file in `tests/ui/`, run `cargo test --test ui_file_name`
  - **UI component examples:**
    - `cargo test component::button::` (all tests within button component module)
    - `cargo test --test ui_components` (the specific integration test file at `tests/ui_components.rs`)
- **Run tests with debug output:** `RUST_LOG=debug cargo test -- --nocapture`
- **Run tests in a specific module from unit tests:**
  - `cargo test --lib bluetooth::scanner::tests` (runs the test mod in `src/bluetooth/scanner.rs`)

## Dealing with Platform-Specific Tests

Use conditional compilation for platform-specific tests:

```rust
#[cfg(target_os = "windows")]
#[test]
fn test_windows_specific_behavior() {
    // Windows-specific test code
}

#[cfg(target_os = "macos")]
#[test]
fn test_macos_specific_behavior() {
    // macOS-specific test code
}
```

## Ensuring Test Quality

- Regularly review test coverage with `cargo tarpaulin` or similar tools
- Add regression tests when bugs are fixed
- Consider running tests on multiple platforms when possible
- Clean up resources in tests, even on test failure paths

## Test Organization and Structure

This section clarifies where and how tests are structured in the project.

### Unit Tests

- **Location**: Unit tests are co-located with the code they are testing. They reside in the *same file* within the `src` directory, encapsulated within a `#[cfg(test)] mod tests { ... }` block.
- **Purpose**: To test individual functions, methods, or small units of code in isolation.

**Example Structure (`src/module/component.rs`):**
```rust
// src/module/component.rs

pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*; // Make items from outer module available

    #[test]
    fn test_add_positive_numbers() {
        assert_eq!(add(2, 3), 5);
    }

    #[test]
    fn test_add_negative_numbers() {
        assert_eq!(add(-2, -3), -5);
    }
}
```

### Integration Tests

- **Location**: Integration tests reside in separate files within the `tests/` directory at the root of the project. You can create subdirectories within `tests/` to organize them further (e.g., `tests/bluetooth/`, `tests/ui/`).
- **Purpose**: To test how different parts of your crate work together, or to test the public API of your library. Each file in the `tests` directory is compiled as a separate crate.
- **Structure**: Test functions in these files are directly annotated with `#[test]` (for synchronous tests) or `#[tokio::test]` (for asynchronous tests). They do *not* need to be wrapped in a `mod tests { ... }` block.

**Example Structure (`tests/my_integration_test.rs`):**
```rust
// tests/my_integration_test.rs

use rustpods; // Assuming 'rustpods' is the name of your crate

#[test]
fn test_public_api_functionality() {
    // Call some public function from your crate
    // assert_eq!(rustpods::some_public_function(), expected_value);
}

#[tokio::test]
async fn test_async_integration_feature() {
    // let result = rustpods::some_async_feature().await;
    // assert!(result.is_ok());
}
```

The examples provided earlier in sections like "Unit Tests", "Integration Tests", "UI Component Tests", and "Bluetooth Tests" illustrate the content of test functions. This "Test Organization and Structure" section focuses on where those test files and modules are located.
